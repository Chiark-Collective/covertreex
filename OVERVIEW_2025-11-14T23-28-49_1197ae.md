## 0. Blurb
- **Apparent Purpose**: `covertreex`, `cli`, and `tools` together implement a parallel compressed cover tree (PCCT) engine with residual-metric traversal, runtime configuration, and guardrailed benchmarking utilities so that large benchmark suites can be reproduced, audited, and evolved.
- **Tech Stack**: Everything is Python (type-annotated, Python 3.11+ style) with heavy reliance on NumPy, optional JAX backends, and extensive numba kernels for hot loops; tooling layers integrate argparse CLIs, JSONL/CSV telemetry, and host-side residual metric kernels.
- **Apparent Maturity**: The codebase is feature-rich—complete runtime/CLI stacks, telemetry, guardrails, and residual-policy automation exist—but several “god” modules (e.g., residual traversal strategy, runtime config, CLI app) and pervasive global registries point to maintainability risk; instrumentation/testing hooks exist yet formal unit tests live outside these dirs, so coverage within the audited scope is implicit rather than enforced.
## 1. File Tree
(Line counts in parentheses reference LOC; only source/config files included.)

covertreex/ — core PCCT implementation layers (API, algorithms, metrics, runtime, telemetry)
├── __init__.py (49) — package metadata plus re-exports for trees, metrics, and baselines.
├── api/ — user-facing runtime + PCCT façade
│   ├── __init__.py (13) — exposes `PCCT`, runtime handles, and residual policy helpers.
│   ├── pcct.py (135) — `PCCT` dataclass wrapping batch insert/delete/query helpers.
│   └── runtime.py (342) — runtime + residual policy dataclasses that feed runtime contexts.
├── algo/ — algorithm kernels for traversal, conflict graphs, MIS, and batch operations
│   ├── __init__.py (41) — aggregates traversal/conflict/MIS/batch APIs.
│   ├── batch/
│   │   ├── __init__.py (21) — re-export shim for batch insert helpers.
│   │   ├── insert.py (601) — orchestrates batch insert planning/execution with logging.
│   │   └── types.py (53) — dataclasses describing insert plans, timings, and prefix batches.
│   ├── batch_delete.py (670) — computes batch delete plans and applies them to trees.
│   ├── batch_insert.py (23) — thin re-export module for batch insert helpers.
│   ├── batch_order.py (5) — exports batch ordering strategy helpers.
│   ├── conflict/
│   │   ├── arena.py (103) — scratch-buffer pools for conflict graph builders.
│   │   ├── base.py (111) — dataclasses for conflict graphs/strategies.
│   │   ├── builders.py (805) — adjacency builders for dense/segmented/residual/grid graph modes.
│   │   ├── __init__.py (6) — exposes core conflict graph API.
│   │   ├── runner.py (515) — high-level conflict graph construction pipeline.
│   │   └── strategies.py (145) — registry of conflict graph strategies + predicates.
│   ├── _grid_numba.py (267) — numba kernels for grid leader selection/micro-MIS.
│   ├── _mis_numba.py (139) — numba implementation of MIS primitives.
│   ├── mis.py (196) — ties conflict graphs to MIS execution and seed selection.
│   ├── order/
│   │   ├── __init__.py (12) — exports batch ordering API.
│   │   ├── helpers.py (68) — preprocessing helpers for batch ordering heuristics.
│   │   └── strategy.py (102) — Hilbert/random ordering implementations.
│   ├── _residual_scope_numba.py (778) — numba kernels for residual scope append/reset/budgeting.
│   ├── _scope_numba.py (1420) — chunking + CSR scope construction kernels.
│   ├── semisort.py (111) — radix-like grouping utilities for traversal output.
│   ├── traverse/
│   │   ├── __init__.py (19) — exposes traversal strategies and residual pairwise helper.
│   │   ├── base.py (132) — traversal dataclasses plus helper utilities.
│   │   ├── runner.py (45) — orchestrates scope traversal for batches.
│   │   └── strategies/
│   │       ├── __init__.py (17) — registers residual/euclidean strategies via side effects.
│   │       ├── common.py (33) — shared helpers (next-chain collection).
│   │       ├── registry.py (59) — traversal strategy registry and selectors.
│   │       ├── euclidean.py (426) — dense/sparse traversal strategies for Euclidean metric.
│   │       └── residual.py (1839) — residual traversal strategy with gating + budgeting logic.
│   ├── _traverse_numba.py (128) — numba-based traversal kernels.
│   └── _traverse_sparse_numba.py (347) — sparse traversal collectors for residual scope streaming.
├── baseline.py (581) — pure-Python cover tree + baseline adapters (external/GPBoost).
├── config.py (11) — backwards-compatible shim onto `covertreex.runtime.config`.
├── core/ — fundamental data structures & persistence
│   ├── __init__.py (42) — re-exports trees, persistence helpers, and metric registry.
│   ├── metrics.py (203) — metric registry plus kernel configuration hooks.
│   ├── _persistence_numba.py (116) — numba COW journal apply kernel.
│   ├── persistence.py (565) — journal construction/apply logic for PCCTree updates.
│   └── tree.py (317) — `TreeBackend`, `PCCTree`, and device conversion helpers.
├── diagnostics.py (9) — thin wrapper exposing runtime diagnostics helpers.
├── exceptions.py (6) — defines `ResidualPairwiseCacheError`.
├── logging.py (9) — shim onto runtime logging helpers.
├── metrics/
│   ├── __init__.py (37) — re-exports residual metric helpers.
│   ├── _residual_numba.py (391) — numba kernels for residual distance/gating math.
│   └── residual/
│       ├── __init__.py (29) — aggregates residual metric APIs.
│       ├── core.py (1025) — host-side residual distance computations, caching, workspaces.
│       ├── _gate_profile_numba.py (111) — quantile reservoir update kernel.
│       ├── host_backend.py (149) — host backend builder for residual correlations.
│       ├── policy.py (402) — residual gate policy/profile definitions & telemetry.
│       └── scope_caps.py (100) — loads memoised scope cap tables.
├── py.typed (0) — PEP 561 marker for type checking consumers.
├── queries/
│   ├── __init__.py (5) — exposes k-NN helpers.
│   ├── _knn_numba.py (455) — numba-driven KNN core.
│   └── knn.py (293) — host-visible KNN/neareset-neighbour wrappers.
├── runtime/
│   ├── __init__.py (31) — exports runtime config/context/logging APIs.
│   ├── config.py (781) — runtime/env configuration parser plus global cache/state.
│   ├── diagnostics.py (250) — process metrics + logging for operations.
│   └── logging.py (21) — logger factory bound to runtime context.
└── telemetry/
    ├── __init__.py (39) — exports artifact/log/schema helpers.
    ├── artifacts.py (74) — artifact path management + run IDs.
    ├── logs.py (361) — benchmark log writer + residual scope cap recorder.
    └── schemas.py (148) — schema constants and runtime breakdown headers.

cli/ — CLI entrypoints for running/resourcing PCCT experiments
├── __init__.py (5) — exposes `runtime_from_args` for compatibility.
├── runtime.py (184) — turns parsed args into runtime overrides.
├── runtime_breakdown.py (842) — benchmarking utility capturing CPU/memory/plots.
└── queries/ — CLI subcommands for queries + telemetry
    ├── __init__.py (16) — re-exports CLI helpers.
    ├── __main__.py (4) — `python -m cli.queries` entrypoint.
    ├── app.py (961) — argparse wiring + main query execution pipeline.
    ├── baselines.py (107) — sequential/external baseline runners.
    ├── benchmark.py (227) — synthetic benchmark harness.
    ├── gate.py (53) — appends gate profile metadata into logs.
    ├── runtime.py (105) — resolves backend/devices + artifact paths for CLI use.
    └── telemetry.py (314) — renders CLI telemetry summaries & formatting helpers.

tools/ — instrumentation + guardrail automation scripts
├── __init__.py (3) — documents helper-script scope.
├── build_residual_gate_profile.py (140) — builds residual gate profiles from recorded batches.
├── export_benchmark_diagnostics.py (171) — aggregates log JSONL into CSV summaries.
├── ingest_residual_gate_profile.py (278) — loads/merges gate profile payloads.
├── residual_guardrail_check.py (273) — enforces guardrail metrics over benchmark logs.
├── residual_scaling_sweep.py (134) — runs scaling sweeps and summarises logs.
└── run_reference_benchmarks.py (306) — orchestrates guardrail + multi-preset benchmark runs.
## 2. APIs
### cli/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Docstring describes CLI scope and `__all__ = ["runtime_from_args"]` re-exports the runtime helper for backwards compatibility.


### cli/queries/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- `__all__` exposes CLI entrypoints (`main`, `run_queries`, benchmark helpers).


### cli/queries/__main__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Acts as `python -m` entrypoint by invoking `main()` when executed directly.


### cli/queries/app.py
**Imports**
- `covertreex`
- `covertreex.metrics`
- `covertreex.telemetry`
- `cli.runtime`

**Functions**
- `cli(ctx, dimension, tree_points, batch_size, queries, k, seed, run_id, metric, backend, precision, devices, enable_numba, enable_sparse_traversal, diagnostics, log_level, mis_seed, conflict_graph, scope_segment_dedupe, scope_chunk_target, scope_chunk_max_segments, scope_chunk_pair_merge, scope_conflict_buffer_reuse, degree_cap, batch_order, batch_order_seed, prefix_schedule, prefix_density_low, prefix_density_high, prefix_growth_small, prefix_growth_mid, prefix_growth_large, residual_lengthscale, residual_variance, residual_inducing, residual_chunk_size, residual_stream_tile, residual_force_whitened, residual_scope_member_limit, residual_scope_bitset, residual_dynamic_query_block, residual_dense_scope_streamer, residual_masked_scope_append, residual_level_cache_batching, residual_scope_caps, residual_scope_cap_default, residual_scope_cap_output, residual_scope_cap_percentile, residual_scope_cap_margin, residual_radius_floor, residual_gate, residual_gate_lookup_path, residual_gate_margin, residual_gate_cap, residual_gate_alpha, residual_gate_eps, residual_gate_band_eps, residual_gate_keep_pct, residual_gate_prune_pct, residual_gate_audit, residual_gate_profile_path, residual_gate_profile_bins, residual_gate_profile_log, residual_prefilter, residual_prefilter_lookup_path, residual_prefilter_margin, residual_prefilter_radius_cap, residual_prefilter_audit, baseline, log_file, no_log_file, build_mode)` (line 132)
- `_validate_residual_runtime(snapshot)` (line 781)
- `run_queries(options)` (line 799)
- `main()` (line 957)

**Classes**
- `QueryCLIOptions` (line 36)
  - `from_namespace(cls, namespace)` (line 108)

### cli/queries/baselines.py
**Imports**
- `covertreex.baseline`

**Functions**
- `_run_sequential_baseline(points, queries, *, k)` (line 27)
- `_run_external_baseline(points, queries, *, k)` (line 45)
- `_run_gpboost_baseline(points, queries, *, k)` (line 65)
- `run_baseline_comparisons(points, queries, *, k, mode)` (line 87)

**Classes**
- `BaselineComparison` (line 19)

### cli/queries/benchmark.py
**Imports**
- `covertreex`
- `covertreex.algo`
- `covertreex.core.tree`
- `covertreex.queries.knn`
- `covertreex.telemetry`

**Functions**
- `_generate_backend_points(rng, count, dimension, *, backend)` (line 30)
- `_build_tree(*, dimension, tree_points, batch_size, seed, prebuilt_points, log_writer, scope_cap_recorder, build_mode, plan_callback)` (line 41)
- `benchmark_knn_latency(*, dimension, tree_points, query_count, k, batch_size, seed, prebuilt_points, prebuilt_tree, prebuilt_queries, build_seconds, log_writer, scope_cap_recorder, build_mode, plan_callback)` (line 158)

**Classes**
- `QueryBenchmarkResult` (line 21)

### cli/queries/gate.py
**Imports**
- `covertreex.telemetry.schemas`

**Functions**
- `_append_gate_profile_log(*, profile_json_path, profile_log_path, run_id, log_metadata, runtime_snapshot, batch_log_path)` (line 10)

**Classes** none

### cli/queries/runtime.py
**Imports**
- `covertreex`
- `covertreex.core.tree`
- `covertreex.telemetry`

**Functions**
- `_gate_active_for_backend(host_backend)` (line 12)
- `_ensure_thread_env_defaults()` (line 25)
- `_thread_env_snapshot()` (line 44)
- `_emit_engine_banner(engine, gate_active, threads)` (line 58)
- `_resolve_backend()` (line 68)
- `_resolve_artifact_arg(path, *, category)` (line 77)

**Classes** none

### cli/queries/telemetry.py
**Imports**
- `covertreex`
- `covertreex.telemetry`

**Functions**
- `initialise_cli_telemetry(*, args, run_id, runtime_snapshot, log_metadata)` (line 33)
- `_median(values)` (line 256)
- `_percentile(values, pct)` (line 262)
- `_per_unit(numerator, denom)` (line 268)
- `_format_pairs(value)` (line 274)
- `_format_int(value)` (line 278)
- `_format_time(seconds)` (line 282)
- `_format_ratio(value)` (line 295)
- `_format_scaled(value, suffix)` (line 303)

**Classes**
- `CLITelemetryHandles` (line 20)
  - `close(self)` (line 26)
- `_ResidualBatchTelemetry` (line 96)
- `ResidualTraversalTelemetry` (line 108)
  - `__init__(self)` (line 111)
  - `observe_plan(self, plan, batch_index, batch_size)` (line 114)
  - `has_data(self)` (line 141)
  - `render_summary(self)` (line 144)
  - `_handle_pairwise_reuse_failure(batch_index, batch_size, flag)` (line 243)

### cli/runtime.py
**Imports**
- `covertreex.api`

**Functions**
- `_get_arg(source, name, default)` (line 8)
- `_residual_policy_from_args(args)` (line 14)
- `runtime_from_args(args, *, default_metric, extra_overrides)` (line 65)

**Classes** none

### cli/runtime_breakdown.py
**Imports**
- `cli.runtime`
- `covertreex`
- `covertreex.algo`
- `covertreex.algo.mis`
- `covertreex.core.tree`
- `covertreex.queries.knn`
- `covertreex.baseline`
- `covertreex.telemetry`

**Functions**
- `_generate_dataset(*, dimension, tree_points, queries, seed)` (line 71)
- `_block_until_ready(value)` (line 92)
- `_read_rss_bytes()` (line 107)
- `_resource_snapshot()` (line 120)
- `_resource_delta(start, end)` (line 133)
- `_compute_cpu_utilisation(cpu_seconds, wall_seconds)` (line 151)
- `_format_bytes(value)` (line 157)
- `_format_resource_summary(cpu_seconds, cpu_utilisation, rss_delta, max_rss)` (line 170)
- `_print_multi_run_summary(all_results)` (line 184)
- `_temporary_runtime_override(**overrides)` (line 219)
- `_chunk_points(points, batch_size)` (line 229)
- `_summarise_batches(batch_metrics, build_seconds)` (line 233)
- `_summarise_chunk_metrics(batch_metrics)` (line 277)
- `_run_pcct_variant(*, label, points, queries, batch_size, k, seed, enable_numba)` (line 306)
- `_run_sequential_baseline(*, label, points, queries, k, constructor)` (line 422)
- `_plot_results(results, *, output, show)` (line 472)
- `_parse_args()` (line 570)
- `main()` (line 674)

**Classes**
- `ImplementationResult` (line 50)
- `_ResourceSnapshot` (line 99)

**Other Top-level Constructs**
- Dataclasses `_ResourceSnapshot` and `ImplementationResult` capture aggregated metrics for repeated runs.


### covertreex/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Defines `__version__` from package metadata and re-exports tree/metric/baseline symbols via `__all__`.


### covertreex/algo/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Module docstring explains scope and `__all__` publishes traversal/conflict/MIS/batch helpers.


### covertreex/algo/_grid_numba.py
**Imports** none

**Functions** none

**Classes** none

### covertreex/algo/_mis_numba.py
**Imports** none

**Functions**
- `run_mis_numba(indptr, indices, seed)` (line 134)

**Classes** none

### covertreex/algo/_residual_scope_numba.py
**Imports** none

**Functions**
- `residual_scope_append(flags, positions, buffer, count, limit, *, respect_limit)` (line 522)
- `residual_scope_append_bitset(flags, bitset_row, positions, count, limit, *, respect_limit)` (line 547)
- `residual_scope_reset(flags, buffer, count)` (line 569)
- `residual_scope_append_masked(flags, buffer, mask_row, distances_row, tile_positions, count, limit, *, respect_limit)` (line 575)
- `residual_scope_append_masked_bitset(flags, bitset_row, mask_row, distances_row, tile_positions, count, limit, *, respect_limit)` (line 607)
- `residual_scope_dynamic_tile_stride(base_stride, active_idx, block_idx_arr, scope_counts, limit_value, budget_enabled, budget_applied, budget_limits)` (line 639)
- `residual_scope_update_budget_state(qi, chunk_points, scan_cap_value, budget_applied, budget_up, budget_down, budget_schedule, budget_indices, budget_limits, budget_final_limits, budget_escalations, budget_low_streak, budget_survivors, budget_early_flags, saturated, saturated_flags)` (line 665)
- `residual_collect_next_chain(next_cache, start, visited, buffer)` (line 734)

**Classes** none

### covertreex/algo/_scope_numba.py
**Imports**
- `covertreex.algo.conflict.arena`

**Functions**
- `_chunk_ranges_from_indptr(indptr, chunk_target, max_segments, keep_mask, pair_counts, pair_merge)` (line 59)
- `_merge_tail_ranges(ranges, weights_prefix, chunk_cap, tail_threshold, *, pair_prefix, pair_cap, pair_tail_threshold)` (line 173)
- `_merge_ranges_by_pair_volume(ranges, pair_prefix, pair_cap)` (line 225)
- `_max_range_pairs(ranges, pair_prefix)` (line 258)
- `_require_numba()` (line 269)
- `warmup_scope_builder()` (line 281)
- `build_scope_csr_from_pairs(owners, members, num_nodes, *, limit, top_levels, parents)` (line 1355)

**Classes**
- `ScopeAdjacencyResult` (line 24)
- `ChunkRangeStats` (line 48)

### covertreex/algo/_traverse_numba.py
**Imports** none

**Functions**
- `_require_numba()` (line 16)
- `build_scopes_numba(mask, parents, next_cache, top_levels)` (line 112)

**Classes** none

### covertreex/algo/_traverse_sparse_numba.py
**Imports**
- `covertreex.queries._knn_numba`

**Functions**
- `collect_sparse_scopes(view, queries, parents, radii)` (line 292)
- `collect_sparse_scopes_csr(view, queries, parents, radii, chunk_target)` (line 324)

**Classes** none

### covertreex/algo/batch/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Pure re-export shim with `__all__` mirroring batch insert dataclasses and helpers.


### covertreex/algo/batch/insert.py
**Imports**
- `covertreex`
- `covertreex.algo.conflict`
- `covertreex.algo.mis`
- `covertreex.algo.order`
- `covertreex.algo.traverse`
- `covertreex.core.metrics`
- `covertreex.core.persistence`
- `covertreex.core.tree`
- `covertreex.diagnostics`
- `covertreex.logging`

**Functions**
- `plan_batch_insert(tree, batch_points, *, backend, mis_seed, apply_batch_order)` (line 43)
- `batch_insert(tree, batch_points, *, backend, mis_seed, apply_batch_order)` (line 128)
- `_batch_insert_impl(op_log, tree, batch_points, *, backend, mis_seed, apply_batch_order)` (line 148)
- `batch_insert_prefix_doubling(tree, batch_points, *, backend, mis_seed, shuffle_seed)` (line 480)

**Classes** none

### covertreex/algo/batch/types.py
**Imports**
- `covertreex.algo.conflict`
- `covertreex.algo.mis`
- `covertreex.algo.traverse`

**Functions** none

**Classes**
- `LevelSummary` (line 12)
- `BatchInsertTimings` (line 20)
- `BatchInsertPlan` (line 27)
- `PrefixBatchGroup` (line 41)
- `PrefixBatchResult` (line 49)

### covertreex/algo/batch_delete.py
**Imports**
- `covertreex`
- `covertreex.algo.batch`
- `covertreex.algo.mis`
- `covertreex.core.tree`
- `covertreex.logging`
- `covertreex.diagnostics`

**Functions**
- `_build_child_links_from_parents(parents_np)` (line 75)
- `_ensure_2d(points, dimension)` (line 87)
- `_collect_descendants(parents_np)` (line 95)
- `_compute_delete_computation(tree, remove_indices, *, backend)` (line 105)
- `_build_plan_from_computation(backend, computation)` (line 519)
- `plan_batch_delete(tree, remove_indices, *, backend)` (line 562)
- `_materialise_tree_from_computation(tree, backend, computation)` (line 573)
- `batch_delete(tree, remove_indices, *, backend)` (line 620)
- `_batch_delete_impl(op_log, tree, remove_indices, *, backend)` (line 636)

**Classes**
- `DeleteLevelSummary` (line 26)
- `BatchDeletePlan` (line 37)
- `_DeleteLevelSummaryData` (line 47)
- `_DeleteComputation` (line 58)

### covertreex/algo/batch_insert.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Uses `__all__` to make batch insert helpers available at the package root.


### covertreex/algo/batch_order.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Re-export shim exposing `BatchOrderResult` and `compute_batch_order` through `__all__`.


### covertreex/algo/conflict/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Re-exports `ConflictGraph` types and `build_conflict_graph` via `__all__`.


### covertreex/algo/conflict/arena.py
**Imports** none

**Functions**
- `get_conflict_arena()` (line 90)
- `get_scope_builder_arena()` (line 94)

**Classes**
- `_ArenaBuffer` (line 9)
  - `ensure(self, size)` (line 12)
  - `capacity_bytes(self)` (line 20)
- `ConflictArena` (line 25)
  - `borrow_sources(self, size)` (line 31)
  - `borrow_targets(self, size)` (line 34)
  - `total_bytes(self)` (line 38)
- `ScopeBuilderArena` (line 46)
  - `borrow_counts(self, size)` (line 55)
  - `borrow_degree_usage(self, size)` (line 61)
  - `borrow_sources(self, size)` (line 67)
  - `borrow_targets(self, size)` (line 70)
  - `borrow_indices(self, size)` (line 73)
  - `total_bytes(self)` (line 77)

### covertreex/algo/conflict/base.py
**Imports**
- `covertreex.core.tree`

**Functions** none

**Classes**
- `ConflictGraph` (line 15)
  - `num_nodes(self)` (line 38)
  - `num_edges(self)` (line 42)
  - `num_scopes(self)` (line 46)
- `ConflictGraphTimings` (line 51)
- `ConflictGraphContext` (line 91)
- `ConflictGraphStrategy` (line 109)
  - `build(self, ctx)` (line 110)

### covertreex/algo/conflict/builders.py
**Imports**
- `covertreex`
- `covertreex.algo._grid_numba`
- `covertreex.algo._scope_numba`
- `covertreex.algo.semisort`
- `covertreex.core.tree`

**Functions**
- `block_until_ready(value)` (line 24)
- `build_dense_adjacency(*, backend, batch_size, scope_indptr, scope_indices, pairwise, radii, residual_pairwise, chunk_target_override)` (line 67)
- `build_segmented_adjacency(*, backend, scope_indices, point_ids, pairwise_np, radii_np)` (line 465)
- `build_residual_adjacency(*, backend, batch_size, scope_indptr, scope_indices, pairwise, radii, residual_pairwise, chunk_target_override)` (line 548)
- `build_grid_adjacency(*, backend, batch_points, batch_levels, radii, scope_indptr, scope_indices)` (line 571)
- `_grid_select_leaders(*, points, levels, radii, seed, num_shifts)` (line 689)
- `_shift_vector(dim, seed)` (line 783)
- `_mix_uint64(values)` (line 788)

**Classes**
- `AdjacencyBuild` (line 31)

### covertreex/algo/conflict/runner.py
**Imports**
- `covertreex`
- `covertreex.algo._scope_numba`
- `covertreex.algo.semisort`
- `covertreex.algo.traverse`
- `covertreex.core.metrics`
- `covertreex.core.tree`
- `covertreex.metrics.residual`
- `covertreex.exceptions`

**Functions**
- `_adaptive_scope_chunk_target(counts)` (line 39)
- `build_conflict_graph(tree, traversal, batch_points, *, backend)` (line 58)

**Classes** none

### covertreex/algo/conflict/strategies.py
**Imports** none

**Functions**
- `register_conflict_strategy(name, *, predicate, factory)` (line 88)
- `registered_conflict_strategies()` (line 99)
- `select_conflict_strategy(runtime, *, residual_mode, has_residual_distances)` (line 136)

**Classes**
- `_DenseConflictStrategy` (line 16)
  - `build(self, ctx)` (line 17)
- `_SegmentedConflictStrategy` (line 29)
  - `build(self, ctx)` (line 30)
- `_GridConflictStrategy` (line 40)
  - `build(self, ctx)` (line 41)
- `_ResidualGridConflictStrategy` (line 52)
  - `build(self, ctx)` (line 53)
- `_ResidualConflictStrategy` (line 64)
  - `build(self, ctx)` (line 65)
- `_ConflictStrategySpec` (line 79)

**Other Top-level Constructs**
- Maintains `_CONFLICT_REGISTRY` of strategy specs populated at import time.


### covertreex/algo/mis.py
**Imports**
- `covertreex`
- `covertreex.algo.conflict`
- `covertreex.core.tree`
- `covertreex.algo._mis_numba`

**Functions**
- `_block_until_ready(value)` (line 22)
- `_repeat_nodes(indptr, dtype)` (line 36)
- `batch_mis_seeds(count, *, seed)` (line 41)
- `run_mis(backend, graph, *, seed)` (line 62)

**Classes**
- `MISResult` (line 31)

### covertreex/algo/order/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Re-exports prefix helpers and batch ordering API through `__all__`.


### covertreex/algo/order/helpers.py
**Imports**
- `covertreex`
- `covertreex.core.tree`

**Functions**
- `prepare_batch_points(*, backend, batch_points, runtime, apply_batch_order)` (line 13)
- `choose_prefix_factor(runtime, domination_ratio)` (line 48)
- `prefix_slices(length)` (line 56)

**Classes** none

### covertreex/algo/order/strategy.py
**Imports** none

**Functions**
- `compute_batch_order(points, *, strategy, seed)` (line 15)
- `_hilbert_permutation(points, *, seed)` (line 38)
- `_axes_to_transpose(coords, bits)` (line 63)
- `_transpose_to_hilbert(transpose, bits, dims)` (line 91)

**Classes**
- `BatchOrderResult` (line 10)

### covertreex/algo/semisort.py
**Imports**
- `covertreex.core.tree`

**Functions**
- `group_by_int(keys, values, *, backend, stable)` (line 18)
- `select_topk_by_level(indices, levels, limit)` (line 79)

**Classes**
- `GroupByResult` (line 12)

### covertreex/algo/traverse/__init__.py
**Imports**
- `covertreex.metrics.residual`

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Imports residual metrics for side effects and exposes traversal symbols via `__all__`.


### covertreex/algo/traverse/base.py
**Imports**
- `covertreex.core.metrics`
- `covertreex.core.tree`

**Functions**
- `block_until_ready(value)` (line 89)
- `broadcast_batch(backend, batch_points)` (line 97)
- `collect_distances(tree, batch, backend)` (line 101)
- `empty_result(backend, batch_size)` (line 106)

**Classes**
- `ResidualTraversalCache` (line 13)
- `TraversalResult` (line 27)
- `TraversalTimings` (line 42)
- `TraversalStrategy` (line 77)
  - `collect(self, tree, batch, *, backend, runtime)` (line 78)

### covertreex/algo/traverse/runner.py
**Imports**
- `covertreex`
- `covertreex.core.tree`

**Functions**
- `traverse_collect_scopes(tree, batch_points, *, backend)` (line 25)

**Classes** none

### covertreex/algo/traverse/strategies/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Imports residual/euclidean strategy modules solely for their registration side effects; `__all__` publishes registry helpers.


### covertreex/algo/traverse/strategies/common.py
**Imports**
- `covertreex.core.tree`

**Functions**
- `_collect_next_chain(tree, start, *, next_cache)` (line 8)

**Classes** none

**Other Top-level Constructs**
- `__all__ = ["_collect_next_chain"]` limits exposure to the traversal helper.


### covertreex/algo/traverse/strategies/euclidean.py
**Imports**
- `covertreex.core.tree`
- `covertreex.logging`
- `covertreex.queries._knn_numba`

**Functions**
- `_collect_euclidean_dense(tree, batch, *, backend, runtime)` (line 58)
- `_collect_euclidean_sparse(tree, batch_points, *, backend, runtime)` (line 221)
- `_ensure_parent_in_selection(selection, row_values, parent_idx, top_levels_np, limit)` (line 357)
- `_conflict_scopes_from_csr(scope_indptr, scope_indices)` (line 378)
- `_max_scope_size(scope_indptr)` (line 394)

**Classes**
- `_EuclideanDenseTraversal` (line 34)
  - `collect(self, tree, batch, *, backend, runtime)` (line 35)
- `_EuclideanSparseTraversal` (line 46)
  - `collect(self, tree, batch, *, backend, runtime)` (line 47)

**Other Top-level Constructs**
- Registers greedy/numba traversal strategies via two `register_traversal_strategy` calls.


### covertreex/algo/traverse/strategies/registry.py
**Imports**
- `covertreex.core.tree`
- `covertreex.logging`

**Functions**
- `register_traversal_strategy(name, *, predicate, factory)` (line 24)
- `registered_traversal_strategies()` (line 40)
- `select_traversal_strategy(runtime, backend)` (line 44)

**Classes**
- `_TraversalStrategySpec` (line 15)

**Other Top-level Constructs**
- Stores `_TRAVERSAL_REGISTRY` list of dynamically registered strategies.


### covertreex/algo/traverse/strategies/residual.py
**Imports**
- `covertreex.core.tree`
- `covertreex.metrics`
- `covertreex.metrics.residual`
- `covertreex.metrics.residual.scope_caps`

**Functions**
- `_residual_find_parents(*, host_backend, query_indices, tree_indices, telemetry)` (line 64)
- `_process_level_cache_hits(*, cache_jobs, level_scope_cache, total_points, tree_indices_np, query_indices, radii, host_backend, distance_telemetry, limit_value, force_whitened, use_masked_append, bitset_enabled, scope_buffers, scope_counts, scope_bitsets, flags_matrix, budget_applied, budget_survivors, trimmed_flags, saturated, saturated_flags, dedupe_hits, observed_radii, shared_workspace)` (line 109)
- `_collect_residual_scopes_streaming_serial(*, tree, host_backend, query_indices, tree_indices, parent_positions, radii, scope_limit, scan_cap, scope_budget_schedule, scope_budget_up_thresh, scope_budget_down_thresh, stream_tile, workspace, telemetry, force_whitened, bitset_enabled, level_cache_batching)` (line 256)
- `_collect_residual_scopes_streaming_parallel(*, tree, host_backend, query_indices, tree_indices, parent_positions, radii, scope_limit, scan_cap, scope_budget_schedule, scope_budget_up_thresh, scope_budget_down_thresh, stream_tile, workspace, telemetry, force_whitened, bitset_enabled, dynamic_query_block, dense_scope_streamer, masked_scope_append, level_cache_batching)` (line 637)
- `_resolve_scope_limits(runtime, gate_active)` (line 1202)
- `_update_scope_budget_state(qi, chunk_points, scan_cap_value, budget_applied, budget_up, budget_down, budget_schedule_arr, budget_indices, budget_limits, budget_final_limits, budget_escalations, budget_low_streak, budget_survivors, budget_early_flags, saturated, saturated_flags)` (line 1235)
- `_residual_gate_active(host_backend)` (line 1315)
- `_append_scope_positions(flags_row, bitset_row, positions, limit_value, scope_count, *, buffer_row)` (line 1326)
- `_append_scope_positions_masked(*, flags_row, bitset_row, mask_row, distances_row, tile_positions, limit_value, scope_count, buffer_row)` (line 1354)
- `_append_scope_positions_numba(flags_row, buffer_row, positions, limit_value, scope_count)` (line 1422)
- `_append_scope_positions_dense(flags_row, positions, limit_value, scope_count)` (line 1451)
- `_append_scope_positions_bitset(flags_row, bitset_row, positions, limit_value, scope_count)` (line 1487)
- `_compute_dynamic_tile_stride(base_stride, active_idx, block_idx_arr, scope_counts, limit_value, budget_enabled, budget_applied, budget_limits)` (line 1509)
- `_resolve_query_block_size(base_block, remaining_active)` (line 1557)
- `_collect_residual(tree, batch_points, *, backend, runtime)` (line 1568)

**Classes**
- `_ResidualTraversal` (line 52)
  - `collect(self, tree, batch, *, backend, runtime)` (line 53)

**Other Top-level Constructs**
- Module defines `_RESIDUAL_SCOPE_*` defaults for budgets/limits and registers itself with `register_traversal_strategy` at import time.


### covertreex/api/__init__.py
**Imports**
- `covertreex.metrics.residual.policy`

**Functions** none

**Classes** none

**Other Top-level Constructs**
- `__all__` re-exports `PCCT`, runtime handles, and `ResidualPolicy`.


### covertreex/api/pcct.py
**Imports**
- `covertreex.algo.batch`
- `covertreex.algo.batch_delete`
- `covertreex.api.runtime`
- `covertreex.core.tree`
- `covertreex.queries.knn`

**Functions**
- `_ensure_points(backend, value)` (line 13)
- `_ensure_indices(backend, value)` (line 26)
- `_convert_tree(tree, backend)` (line 31)

**Classes**
- `PCCT` (line 45)
  - `fit(self, points, *, apply_batch_order, mis_seed, return_plan)` (line 51)
  - `insert(self, batch_points, *, mis_seed, apply_batch_order, return_plan)` (line 73)
  - `delete(self, indices, *, return_plan)` (line 95)
  - `knn(self, query_points, *, k, return_distances)` (line 109)
  - `nearest(self, query_points, *, return_distances)` (line 129)
  - `_require_tree(self)` (line 132)

### covertreex/api/runtime.py
**Imports**
- `covertreex`
- `covertreex.metrics.residual.policy`

**Functions**
- `_maybe_tuple(value)` (line 10)
- `_apply_if_present(target, key, value)` (line 18)
- `_policy_to_overrides(policy)` (line 23)

**Classes**
- `Residual` (line 50)
  - `as_overrides(self, base_policy)` (line 76)
  - `from_config(cls, config)` (line 81)
  - `from_policy(cls, policy)` (line 109)
  - `to_policy(self, base)` (line 135)
- `Runtime` (line 167)
  - `to_config(self, base)` (line 203)
  - `activate(self)` (line 274)
  - `describe(self)` (line 280)
  - `with_updates(self, **kwargs)` (line 302)
  - `from_active(cls)` (line 306)
  - `from_config(cls, config)` (line 310)

### covertreex/baseline.py
**Imports** none

**Functions**
- `_log2_ceil(value)` (line 230)
- `_euclidean(a, b)` (line 236)
- `_pairwise_distances(points, query)` (line 240)
- `_sort_vectors_decreasing_inplace(a, b)` (line 245)
- `has_external_cover_tree()` (line 466)
- `has_gpboost_cover_tree()` (line 570)

**Classes**
- `BaselineNode` (line 256)
- `BaselineCoverTree` (line 264)
  - `from_points(cls, points)` (line 272)
  - `_children_at_level(self, level)` (line 290)
  - `insert_point(self, point_index)` (line 296)
  - `nearest(self, query)` (line 343)
  - `knn(self, queries, k, *, return_distances)` (line 353)
- `ExternalCoverTreeBaseline` (line 397)
  - `__init__(self, tree, points)` (line 400)
  - `from_points(cls, points, *, leafsize, base)` (line 407)
  - `num_points(self)` (line 427)
  - `nearest(self, query)` (line 430)
  - `knn(self, queries, *, k, return_distances)` (line 434)
- `GPBoostCoverTreeBaseline` (line 470)
  - `__init__(self, *, cover_tree, levels, points)` (line 473)
  - `from_points(cls, points)` (line 487)
  - `num_points(self)` (line 507)
  - `nearest(self, query)` (line 510)
  - `knn(self, queries, *, k, return_distances)` (line 514)

### covertreex/config.py
**Imports**
- `covertreex.runtime.config`
- `covertreex.runtime`

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Back-compat shim that wildcard-imports `covertreex.runtime.config` and mirrors its `__all__`.


### covertreex/core/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- `__all__` exposes PCCT structures, persistence helpers, and metric registries.


### covertreex/core/_persistence_numba.py
**Imports** none

**Functions**
- `_require_numba()` (line 16)
- `apply_journal_cow(parents_in, levels_in, children_in, next_in, inserted_parents, inserted_levels, head_parents, head_values, next_nodes, next_values, parents_out, levels_out, children_out, next_out, base_length)` (line 76)

**Classes** none

### covertreex/core/metrics.py
**Imports**
- `covertreex`

**Functions**
- `_ensure_2d(backend, array)` (line 58)
- `_euclidean_pairwise(backend, lhs, rhs)` (line 65)
- `_euclidean_pointwise(backend, lhs, rhs)` (line 77)
- `_load_runtime_registry()` (line 90)
- `_residual_pairwise(backend, lhs, rhs)` (line 106)
- `_residual_pointwise(backend, lhs, rhs)` (line 115)
- `get_metric(name)` (line 151)
- `configure_residual_metric(*, pairwise, pointwise)` (line 159)
- `reset_residual_metric()` (line 171)
- `available_metrics()` (line 185)

**Classes**
- `PairwiseKernel` (line 11)
  - `__call__(self, backend, lhs, rhs)` (line 12)
- `PointwiseKernel` (line 16)
  - `__call__(self, backend, lhs, rhs)` (line 17)
- `Metric` (line 22)
  - `pairwise(self, backend, lhs, rhs)` (line 29)
  - `pointwise(self, backend, lhs, rhs)` (line 32)
- `MetricRegistry` (line 36)
  - `__init__(self)` (line 39)
  - `register(self, metric, *, overwrite)` (line 42)
  - `get(self, name)` (line 48)
  - `names(self)` (line 54)

### covertreex/core/persistence.py
**Imports**
- `covertreex`
- `covertreex.core._persistence_numba`
- `covertreex.core.tree`

**Functions**
- `_ensure_array(backend, values, *, dtype)` (line 24)
- `_normalise_index(index)` (line 28)
- `_required_length_along_axis(index, current)` (line 34)
- `clone_array_segment(backend, source, updates, *, dtype)` (line 49)
- `clone_tree_with_updates(tree, *, points_updates, top_level_updates, parent_updates, child_updates, level_offset_updates, si_cache_updates, next_cache_updates)` (line 82)
- `_pool_next_capacity(current, required)` (line 124)
- `_compute_level_offsets_incremental(current_offsets, inserted_levels)` (line 197)
- `_build_head_and_sibling_updates(inserted_parents, base_children, *, base_length, pool)` (line 243)
- `build_persistence_journal(tree, *, backend, inserted_points, inserted_levels, inserted_parents, inserted_si, pool)` (line 293)
- `apply_persistence_journal(tree, journal, *, backend)` (line 345)
- `_apply_journal_numba(tree, journal, *, backend)` (line 362)
- `_apply_journal_numpy(tree, journal, *, backend)` (line 422)
- `_apply_journal_clone(tree, journal, *, backend)` (line 483)

**Classes**
- `SliceUpdate` (line 17)
- `JournalScratchPool` (line 133)
  - `_request(self, name, required)` (line 143)
  - `head_parents(self, required)` (line 154)
  - `head_values(self, required)` (line 157)
  - `next_nodes(self, required)` (line 160)
  - `next_values(self, required)` (line 163)
  - `children(self, required)` (line 166)
- `PersistenceJournal` (line 174)
  - `inserted_count(self)` (line 189)
  - `total_length(self)` (line 193)

### covertreex/core/tree.py
**Imports**
- `covertreex`
- `covertreex.logging`

**Functions**
- `_device_put_default(value)` (line 20)
- `_context_backend()` (line 117)
- `get_runtime_backend()` (line 123)
- `compute_level_offsets(backend, top_levels)` (line 129)

**Classes**
- `TreeBackend` (line 27)
  - `jax(cls, *, precision)` (line 45)
  - `numpy(cls, *, precision)` (line 64)
  - `gpu(cls, *, precision)` (line 81)
  - `array(self, value, *, dtype)` (line 88)
  - `zeros(self, shape, *, dtype)` (line 94)
  - `ones(self, shape, *, dtype)` (line 97)
  - `empty(self, shape, *, dtype)` (line 100)
  - `to_numpy(self, value)` (line 103)
- `TreeLogStats` (line 147)
  - `as_dict(self)` (line 155)
- `PCCTree` (line 165)
  - `__post_init__(self)` (line 185)
  - `_validate_shapes(self)` (line 194)
  - `num_points(self)` (line 221)
  - `num_levels(self)` (line 225)
  - `dimension(self)` (line 229)
  - `materialise(self)` (line 234)
  - `replace(self, *, points, top_levels, parents, children, level_offsets, si_cache, next_cache, stats, backend)` (line 250)
  - `to_backend(self, backend)` (line 277)
  - `empty(cls, *, dimension, backend)` (line 292)
  - `is_empty(self)` (line 310)
  - `validate(self)` (line 314)

### covertreex/diagnostics.py
**Imports**
- `covertreex.runtime.diagnostics`
- `covertreex.runtime`

**Functions** none

**Classes** none

### covertreex/exceptions.py
**Imports** none

**Functions** none

**Classes**
- `ResidualPairwiseCacheError` (line 4)

### covertreex/logging.py
**Imports**
- `covertreex.runtime.logging`
- `covertreex.runtime`

**Functions** none

**Classes** none

### covertreex/metrics/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Pure re-export surface for residual metric helpers with `__all__`.


### covertreex/metrics/_residual_numba.py
**Imports** none

**Functions**
- `compute_distance_chunk(v_query, v_chunk, kernel_chunk, p_i, p_chunk, norm_query, norm_chunk, radius, eps)` (line 208)
- `gate1_whitened_mask(v_query, v_chunk, threshold)` (line 283)
- `distance_block_no_gate(v_matrix, p_diag, v_norm_sq, query_indices, chunk_indices, kernel_block, radii, eps)` (line 307)

**Classes** none

### covertreex/metrics/residual/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Extends `__all__` with symbols from submodules (core, scope_caps) plus policy/host helpers; import side effects register components.


### covertreex/metrics/residual/_gate_profile_numba.py
**Imports** none

**Functions**
- `update_quantile_reservoir(bin_indices, values, samples, sample_counts, total_counts)` (line 48)

**Classes** none

### covertreex/metrics/residual/core.py
**Imports**
- `covertreex`

**Functions**
- `_default_point_decoder(values)` (line 37)
- `_finalize_gate_profile(backend)` (line 249)
- `set_residual_backend(backend)` (line 257)
- `get_residual_backend()` (line 264)
- `_normalise_indices(indices, total)` (line 274)
- `decode_indices(host_backend, payload)` (line 280)
- `_compute_distances_from_kernel_block(backend, lhs_indices, rhs_indices, kernel_block)` (line 290)
- `_compute_gate1_whitened(matrix, *, regularisation)` (line 323)
- `_ensure_whitened_cache(backend)` (line 362)
- `_compute_gate1_distances(backend, query_index, candidate_idx)` (line 372)
- `compute_whitened_block(backend, query_indices, chunk_indices, *, workspace)` (line 387)
- `_resolve_gate1_config(backend, *, policy)` (line 422)
- `_audit_gate1_pruned(*, backend, query_index, candidate_idx, kernel_vals, keep_mask, radius, whitened_distances)` (line 457)
- `compute_residual_distances_with_kernel(backend, lhs_indices, rhs_indices, *, chunk_size)` (line 502)
- `compute_residual_distances(backend, lhs_indices, rhs_indices, *, chunk_size)` (line 533)
- `compute_residual_distances_from_kernel(backend, lhs_indices, rhs_indices, kernel_block)` (line 551)
- `compute_residual_lower_bounds_from_kernel(backend, lhs_indices, rhs_indices, kernel_block)` (line 562)
- `compute_residual_pairwise_matrix(host_backend, batch_indices, *, telemetry)` (line 582)
- `compute_residual_distances_with_radius(backend, query_index, chunk_indices, kernel_row, radius, *, workspace, telemetry, force_whitened)` (line 611)
- `compute_residual_distances_block_no_gate(backend, query_indices, chunk_indices, kernel_block, radii)` (line 832)
- `compute_residual_distance_single(backend, lhs_index, rhs_index)` (line 870)
- `configure_residual_correlation(backend)` (line 884)

**Classes**
- `KernelProvider` (line 27)
  - `__call__(self, row_indices, col_indices)` (line 28)
- `PointDecoder` (line 32)
  - `__call__(self, values)` (line 33)
- `ResidualCorrHostData` (line 53)
  - `__post_init__(self)` (line 109)
  - `num_points(self)` (line 136)
  - `rank(self)` (line 140)
  - `v_matrix_view(self, dtype)` (line 143)
  - `p_diag_view(self, dtype)` (line 155)
  - `kernel_diag_view(self, dtype)` (line 167)
- `ResidualWorkspace` (line 181)
  - `__post_init__(self)` (line 190)
  - `ensure_capacity(self, rows, cols)` (line 193)
  - `gram_view(self, rows, cols)` (line 200)
  - `dist2_view(self, rows, cols)` (line 204)
  - `mask_view(self, rows, cols)` (line 208)
  - `_resize(self, rows, cols)` (line 212)
- `ResidualDistanceTelemetry` (line 221)
  - `record_whitened(self, rows, cols, seconds)` (line 231)
  - `record_kernel(self, rows, cols, seconds)` (line 238)

**Other Top-level Constructs**
- Holds module-wide residual backend selection (via `set_residual_backend`/`get_residual_backend`).


### covertreex/metrics/residual/host_backend.py
**Imports** none

**Functions**
- `_rbf_kernel(x, y, *, variance, lengthscale)` (line 14)
- `_build_sgemm_rbf_provider(points, *, variance, lengthscale)` (line 28)
- `_point_decoder_factory(points)` (line 60)
- `build_residual_backend(points, *, seed, inducing_count, variance, lengthscale, chunk_size, rng)` (line 90)

**Classes** none

### covertreex/metrics/residual/policy.py
**Imports**
- `covertreex`

**Functions**
- `_normalise_percentiles(values)` (line 19)
- `_format_percentile(value)` (line 34)
- `get_residual_policy(runtime)` (line 388)

**Classes**
- `ResidualGateTelemetry` (line 42)
  - `snapshot(self)` (line 48)
  - `delta(self, snapshot)` (line 51)
- `ResidualGateProfile` (line 62)
  - `create(cls, *, bins, radius_max, path, radius_eps, quantile_percentiles, quantile_sample_cap)` (line 81)
  - `_bin_indices(self, values)` (line 121)
  - `_record_quantiles(self, idx, whitened)` (line 125)
  - `record_chunk(self, *, residual_distances, whitened_distances, inclusion_mask)` (line 145)
  - `record_false_negatives(self, *, residual_distances, whitened_distances, inclusion_mask)` (line 168)
  - `annotate_metadata(self, **metadata)` (line 182)
  - `_cumulative_whitened(self)` (line 189)
  - `_cumulative_ratio(self)` (line 192)
  - `_quantile_payload(self)` (line 195)
  - `to_dict(self)` (line 216)
  - `dump(self, path, *, force)` (line 245)
- `ResidualGateLookup` (line 259)
  - `from_payload(cls, payload, *, margin, keep_pct, prune_pct)` (line 266)
  - `load(cls, path, *, margin, keep_pct, prune_pct)` (line 311)
  - `thresholds(self, radius)` (line 323)
- `ResidualPolicy` (line 338)
  - `from_runtime(cls, runtime)` (line 362)

**Other Top-level Constructs**
- Declares constants like `RESIDUAL_EPS` and defaults for gate profiling.


### covertreex/metrics/residual/scope_caps.py
**Imports** none

**Functions**
- `_normalise_cap(value)` (line 15)
- `_coerce_level_list(level_field)` (line 23)
- `get_scope_cap_table(path)` (line 78)
- `reset_scope_cap_cache()` (line 91)

**Classes**
- `ResidualScopeCapTable` (line 32)
  - `from_payload(cls, payload)` (line 37)
  - `load(cls, path)` (line 62)
  - `lookup(self, levels)` (line 67)

**Other Top-level Constructs**
- Maintains `_SCOPE_CAP_CACHE` guarded by `_CACHE_LOCK` for memoised cap tables.


### covertreex/queries/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Defines docstring and `__all__ = ["knn", "nearest_neighbor"]`.


### covertreex/queries/_knn_numba.py
**Imports**
- `covertreex.core.tree`

**Functions**
- `_to_numpy(array, backend, *, dtype)` (line 36)
- `materialise_tree_view(tree)` (line 315)
- `knn_numba(view, queries, *, k, return_distances)` (line 370)
- `materialise_tree_view_cached(tree)` (line 433)

**Classes**
- `NumbaTreeView` (line 23)

### covertreex/queries/knn.py
**Imports**
- `covertreex`
- `covertreex.core.tree`
- `covertreex.diagnostics`
- `covertreex.logging`
- `covertreex.queries._knn_numba`

**Functions**
- `_to_numpy_array(backend, array, dtype)` (line 23)
- `_fallback_bruteforce(query, points, k)` (line 68)
- `_single_query_knn(query, *, points, si_cache, child_cache, root_indices, k)` (line 79)
- `knn(tree, query_points, *, k, return_distances, backend)` (line 165)
- `_knn_impl(op_log, tree, query_points, *, k, return_distances, backend)` (line 185)
- `nearest_neighbor(tree, query_points, *, return_distances, backend)` (line 280)

**Classes**
- `_ChildChainCache` (line 29)
  - `__init__(self, children, next_cache)` (line 34)
  - `get(self, parent)` (line 40)

### covertreex/runtime/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Re-exports runtime helpers/loggers/diagnostics via `__all__`.


### covertreex/runtime/config.py
**Imports** none

**Functions**
- `_bool_from_env(value, *, default)` (line 62)
- `_parse_devices(raw)` (line 73)
- `_parse_optional_int(raw)` (line 84)
- `_normalise_precision(value)` (line 93)
- `_parse_conflict_graph_impl(value)` (line 102)
- `_parse_batch_order_strategy(value)` (line 113)
- `_parse_prefix_schedule(value, *, default)` (line 124)
- `_parse_optional_float(raw, *, default)` (line 139)
- `_infer_precision_from_env()` (line 148)
- `_infer_backend_from_env()` (line 158)
- `_device_label(device)` (line 165)
- `_resolve_jax_devices(requested)` (line 170)
- `_parse_scope_budget_schedule(raw)` (line 196)
- `_apply_jax_runtime_flags(config)` (line 594)
- `_configure_logging(level)` (line 612)
- `runtime_context()` (line 663)
- `runtime_config()` (line 675)
- `configure_runtime(config)` (line 681)
- `set_runtime_context(context)` (line 690)
- `_set_runtime_context(context)` (line 698)
- `reset_runtime_config_cache()` (line 703)
- `reset_runtime_context()` (line 707)
- `describe_runtime()` (line 714)

**Classes**
- `RuntimeConfig` (line 223)
  - `jax_enable_x64(self)` (line 283)
  - `primary_platform(self)` (line 287)
  - `from_env(cls)` (line 293)
- `RuntimeContext` (line 624)
  - `activate(self)` (line 631)
  - `get_backend(self)` (line 640)

**Other Top-level Constructs**
- Module-level caches (`_RUNTIME_CONFIG_CACHE`, `_RUNTIME_CONTEXT`, env flags) hold active runtime state and warnings.


### covertreex/runtime/diagnostics.py
**Imports**
- `covertreex`

**Functions**
- `_now_snapshot(*, with_resources)` (line 28)
- `_read_rss_bytes()` (line 59)
- `_query_gpu_memory()` (line 75)
- `_mark_gpu_failure()` (line 122)
- `_format_bytes(value)` (line 127)
- `_format_float(value)` (line 138)
- `_diff_optional(end, start, *, scale)` (line 142)
- `_max_optional(*values)` (line 148)
- `_stringify(value)` (line 226)
- `log_operation(logger, label, *, level)` (line 239)

**Classes**
- `_ProcessSnapshot` (line 17)
- `OperationMetrics` (line 156)
  - `__enter__(self)` (line 166)
  - `__exit__(self, exc_type, exc, _tb)` (line 171)
  - `add_metadata(self, **kwargs)` (line 177)
  - `_emit(self)` (line 180)
  - `_compute_metrics(self)` (line 187)

### covertreex/runtime/logging.py
**Imports** none

**Functions**
- `get_logger(name)` (line 11)

**Classes** none

### covertreex/telemetry/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- `__all__` publishes artifact helpers, log writers, and schema constants.


### covertreex/telemetry/artifacts.py
**Imports** none

**Functions**
- `artifact_root(create)` (line 22)
- `resolve_artifact_path(path, *, category, create_parents)` (line 32)
- `timestamped_artifact(*, category, prefix, suffix, create_parents)` (line 55)
- `generate_run_id(*, prefix)` (line 69)

**Classes** none

### covertreex/telemetry/logs.py
**Imports** none

**Functions**
- `_read_rss_bytes()` (line 26)
- `_ms(value)` (line 44)
- `_summarise_metric(record, prefix, values)` (line 48)
- `_metric_summary(values)` (line 62)
- `_augment_residual_scope_metrics(record, residual_cache)` (line 78)

**Classes**
- `BenchmarkLogWriter` (line 119)
  - `__init__(self, path, *, run_id, runtime, metadata)` (line 120)
  - `close(self)` (line 142)
  - `record_batch(self, *, batch_index, batch_size, plan, extra)` (line 146)
  - `__enter__(self)` (line 263)
  - `__exit__(self, exc_type, exc, tb)` (line 266)
- `ResidualScopeCapRecorder` (line 270)
  - `__init__(self, *, output, percentile, margin, radius_floor)` (line 271)
  - `annotate(self, **metadata)` (line 281)
  - `capture(self, plan)` (line 287)
  - `dump(self)` (line 313)

### covertreex/telemetry/schemas.py
**Imports** none

**Functions**
- `runtime_breakdown_fieldnames(*, include_run)` (line 107)

**Classes** none

**Other Top-level Constructs**
- Declares numerous schema constants/IDs for telemetry payload validation.


### tools/__init__.py
**Imports** none

**Functions** none

**Classes** none

**Other Top-level Constructs**
- Module docstring clarifies purpose; `__all__ = []` signals intentional empty public API.


### tools/build_residual_gate_profile.py
**Imports**
- `covertreex`
- `covertreex.api`
- `covertreex.core.metrics`
- `covertreex.metrics`
- `covertreex.metrics.residual`
- `covertreex.telemetry`

**Functions**
- `_parse_args()` (line 22)
- `_build_backend(args)` (line 51)
- `_record_pairs(backend, profile, pair_chunk)` (line 65)
- `main()` (line 100)

**Classes** none

### tools/export_benchmark_diagnostics.py
**Imports** none

**Functions**
- `_load_records(path)` (line 11)
- `_detect_metric(records)` (line 27)
- `_aggregate(records)` (line 35)
- `main()` (line 102)

**Classes** none

### tools/ingest_residual_gate_profile.py
**Imports**
- `covertreex.telemetry.schemas`

**Functions**
- `_coerce_array(values, name)` (line 34)
- `_coerce_counts(values, name)` (line 41)
- `_iter_payloads(path)` (line 48)
- `_extract_profile(record, *, source)` (line 74)
- `load_profile_records(paths)` (line 126)
- `merge_profile_records(records, *, metadata_overrides)` (line 139)
- `_parse_metadata(pairs)` (line 220)
- `_build_arg_parser()` (line 230)
- `main(argv)` (line 253)

**Classes**
- `ProfileRecord` (line 18)

### tools/residual_guardrail_check.py
**Imports** none

**Functions**
- `_default_log_path()` (line 52)
- `_build_cli_command(args, log_path)` (line 57)
- `_load_records(path)` (line 85)
- `parse_guardrail_metrics(path)` (line 94)
- `evaluate_metrics(metrics, *, min_whitened_coverage, max_median_semisort_ms, require_gate1_prunes, require_pairwise_reuse, min_dominated_batches)` (line 123)
- `_write_summary(path, metrics)` (line 158)
- `main(argv)` (line 175)

**Classes**
- `GuardrailMetrics` (line 29)
  - `whitened_coverage(self)` (line 38)
  - `all_pairwise_reused(self)` (line 44)
  - `semisort_median_seconds(self)` (line 48)

### tools/residual_scaling_sweep.py
**Imports** none

**Functions**
- `parse_args()` (line 16)
- `_summary_from_log(path)` (line 51)
- `_run_size(size, args)` (line 79)
- `main()` (line 110)

**Classes** none

### tools/run_reference_benchmarks.py
**Imports** none

**Functions**
- `_default_output_dir()` (line 108)
- `_jobs()` (line 113)
- `_export_csv(log_path, csv_path, python_executable)` (line 213)
- `_run_job(job, log_path, csv_path, env, python_executable, skip_existing)` (line 226)
- `_select_jobs(all_jobs, names)` (line 250)
- `main(argv)` (line 261)

**Classes**
- `BenchmarkJob` (line 35)
  - `build_command(self, log_path, python_executable)` (line 51)
  - `metadata(self)` (line 91)

## 3. Architecture & Notable Observations
- **Layered data path**: `covertreex/core` defines the persistent `PCCTree` structure and metric registry, `covertreex/algo` provides traversal/conflict/MIS/batch kernels (many backed by numba), and `covertreex/metrics/residual` layers the residual-distance backend on top. `covertreex/api` plus `cli/queries` wrap these primitives into user-facing entrypoints, while `covertreex/runtime` manages backend/device selection and logging. Telemetry surfaces (`covertreex/telemetry`, `cli/queries/telemetry.py`, and the scripts under `tools/`) close the loop by persisting benchmark logs and validating guardrails.
- **Residual metric pipeline**: Host-side residual computation (`metrics/residual/core.py`, `policy.py`, `host_backend.py`) feeds traversal via `metrics.residual` exports. Residual traversal (`algo/traverse/strategies/residual.py`) is tightly coupled to gate policy, scope budgets, and telemetry, calling into `_residual_scope_numba` kernels and the policy layer’s `ResidualGateProfile`. Gate automation is extended further by CLI hooks (`cli/queries/gate.py`) and instrumentation scripts (`tools/build_residual_gate_profile.py`, `tools/ingest_residual_gate_profile.py`, `tools/residual_guardrail_check.py`).
- **Traversal/conflict orchestration**: `algo/traverse` collects scopes which are then converted to conflict graphs via `algo/conflict` before MIS (`algo/mis`) finalises batch selections. Strategy registries (`algo/conflict/strategies`, `algo/traverse/strategies/registry`) rely on global lists populated at import time, so import ordering and stateful registration matter; this pattern also appears in metric registries (`core/metrics`) and runtime config caches.
- **Runtime + CLI coupling**: `cli/queries/app.py` owns the giant argparse surface and passes dozens of knobs directly into `covertreex.api.Runtime` and traversal strategies. The CLI interacts deeply with runtime globals (`runtime/config.py`) and telemetry (log writers, artifact layout). Because `cli/queries/app.cli()` exposes ~70 parameters, configuration drift or undocumented defaults are a real risk; splitting responsibilities or grouping related options would improve auditability.
- **Instrumentation & guardrails**: Telemetry modules stream JSONL/CSV plus schema definitions, while `tools/run_reference_benchmarks.py` and guardrail scripts enforce pre-run checks (coverage, semisort latency, gate reuse). These scripts expect deterministic artifact layouts (`telemetry.artifacts`) and reuse CLI entrypoints, so changing log formats requires synchronized updates across modules (`docs/`, `tools/`, CLI). The presence of smoke artifacts under `artifacts/benchmarks/reference` shows the suite is already in-use.
- **Notable risks / hot spots**:
  - `algo/traverse/strategies/residual.py` (1.8k LOC) mixes batching, gate heuristics, telemetry, and scope assembly; it is effectively a subsystem on its own and difficult to reason about or unit test. Consider splitting cache-handling, mask/gate math, and traversal orchestration.
  - `runtime/config.py` (781 LOC) owns env parsing, logging init, backend selection, and global singleton caches. Mutating globals (`_RUNTIME_CONTEXT`, `_RUNTIME_CONFIG_CACHE`) makes reproducibility tricky, especially for concurrent tests or embedding in other programs.
  - The CLI main (`cli/queries/app.py`) is similarly monolithic, interleaving argument parsing, validation, execution, logging, and telemetry; opportunities exist to extract builder objects or config schemas that can be tested independently.
  - Heavy reliance on global registries (`covertreex/algo/conflict/strategies`, `algo/traverse/strategies/registry`, `metrics/core`) and cached policy objects means correctness can hinge on import side effects. Auditors should verify that tests cover registration order and reset paths (some `reset_*` utilities exist but live elsewhere).
  - Many performance-critical modules depend on numba kernels (`*_numba.py`). There is light scaffolding (`_require_numba`) but limited fallback logic; missing numba or incompatible versions could fail late at runtime. Ensuring guardrail scripts validate the environment before long runs would reduce churn.
